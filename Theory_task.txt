Task 1. Приведу 2 примера использования AOP в реальной жизни

Система безопасности в доме. Есть много аспектов и точек соединения. Логирование особенно важно для безопасности, записывать каждое действие модулей безопасности, обнаружение угроз, учет активности пользователей, отслеживание потенциальной опасности. Анализ всей собранной информации.

Когда человек входит в дом, срабатывает охранная система и регистрирует это действие.

Система проверяет, есть ли у человека разрешение на вход.

Здесь сама деятельность человека не касается безопасности, но аспекты реализуются автоматически.



Обслуживание транспорта (например автомобиль)

Каждый раз, когда автомобиль заводится, происходит диагностика систем: проверяется уровень топлива, масла, состояние аккумулятора (логирование и проверка состояния).

Диагностика не является основной функцией автомобиля, но она важна для его безопасного и корректного функционирования.



В этих примерах мы не нагромождаем основной функционал и не мешаем ему, применяя AOP, ведем журнал действий и отслеживаем все активности. Логирование живет само по себе и при этом очень помогает нам.



Task 2. @AfterThrowing и @AfterReturning в целом, схожие аннотации, но все же у каждого свой кейс использования. AfterThrowing используется для того случая, когда метод кинет exception, а AfterReturning следует использовать, когда ожидаешь нормальное завершение метода, если он что-то возвращает.

Task 3. В существующем проекте я добавил @Around для показа результата отработки joinPoint и анализа времени исполнения

Task 5. В Spring аннотация @Transactional обеспечивает автоматическое управление транзакцией. Она позволяет выполнять код в рамках транзакции, что гарантирует, что все изменения, внесенные в базу данных, будут зафиксированы (committed) или отменены (rolled back) при возникновении ошибки.

В Spring @Transactional работает на основе прокси — специального объекта, который оборачивает оригинальный метод и добавляет транзакционное поведение. Прокси обеспечивает управление транзакцией, началом и завершением транзакционного контекста, откатом или фиксацией транзакции. Когда метод помечен @Transactional, Spring создает прокси-объект вокруг этого метода. Вместо того, чтобы напрямую вызывать метод, приложение взаимодействует с этим прокси. Существуют особые моменты, в которых @Transactional не будет активен. Если мы используем вложенный метод



@Service

public class MyService {



    @Transactional

    public void methodA() {

        // транзакция начнется

        methodB(); // внутренний вызов, методB не будет в транзакции!

    }



    @Transactional

    public void methodB() {

        // транзакция не будет начата, так как метод вызван напрямую

    }

}



Когда мы используем this для вызова методов внутри класса, помеченного аннотацией @Transactional, транзакционное поведение не будет применено, поскольку this ссылается на текущий экземпляр класса, а не на прокси-объект.





